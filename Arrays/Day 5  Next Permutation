---
Difficulty: Medium
Source: 160 Days of Problem Solving
Tags:
  - Arrays
  - permutation
  - constructive algo
---

#  _Day 5. Next Permutation_ 

The problem can be found at the following link: [Problem Link](https://www.geeksforgeeks.org/batch/gfg-160-problems/track/arrays-gfg-160/problem/next-permutation5226)


## üí° **Problem Description:**

Given an array of integers `arr[]` representing a permutation, implement the next permutation that rearranges the numbers into the lexicographically next greater permutation. If no such permutation exists, rearrange the numbers into the lowest possible order (i.e., sorted in ascending order).

**Note:** A permutation of `n` numbers is any possible arrangement of all the integers in the range `[1, n]`, where each integer occurs exactly once.

## üîç **Example Walkthrough:**

**Input:**  
`arr = [2, 4, 1, 7, 5, 0]`  
**Output:**  
`[2, 4, 5, 0, 1, 7]`  

**Explanation:**  
The next permutation of the given array is `[2, 4, 5, 0, 1, 7]`.

**Input:**  
`arr = [3, 2, 1]`  
**Output:**  
`[1, 2, 3]`  

**Explanation:**  
As `arr[]` is the last permutation, the next permutation is the lowest one.

**Input:**  
`arr = [3, 4, 2, 5, 1]`  
**Output:**  
`[3, 4, 5, 1, 2]`  

**Explanation:**  
The next permutation of the given array is `[3, 4, 5, 1, 2]`.

### Constraints:
- `1 ‚â§ arr.size() ‚â§ 10^5`
- `1 ‚â§ arr[i] ‚â§ 10^5`


## üéØ **My Approach:**

   - Start from the rightmost side of the array and find the first index `i` such that `arr[i] < arr[i+1]`.
   - This index `i` is the pivot where the next permutation needs to be modified.
   - Find the smallest element on the right of `i` that is greater than `arr[i]` and swap them. This ensures the permutation becomes lexicographically larger.
   - Reverse the elements from `i+1` to the end of the array to get the next smallest permutation.


## üïí **Time and Auxiliary Space Complexity**üìù

- **Expected Time Complexity:** O(n)
- **Expected Auxiliary Space Complexity:** O(1)

## üìù **Solution Code**

## Code (Java)

```java
class Solution {
    void nextPermutation(int[] arr) {
        int n = arr.length;
        int i = n - 2, j = n - 1;

        while (i >= 0 && arr[i] >= arr[i + 1])
            i--;

        if (i >= 0) {
            while (arr[j] <= arr[i])
                j--;

            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }

        reverse(arr, i + 1, n - 1);
    }

    void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
}
```

# üéØ **Contribution and Support:**

For discussions, questions, or doubts related to this solution, feel free to connect on LinkedIn: [Any Questions](https://www.linkedin.com/in/sanjana-yadav007). Let‚Äôs make this learning journey more collaborative!

‚≠ê If you find this helpful, please give this repository a star! ‚≠ê

---
